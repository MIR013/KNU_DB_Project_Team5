[추가 과제 2: 트랜잭션에 의한 동시성 제어 구현]
 - 1. 사용자가 동시에 접속할 수 있도록 한다
    - 본 웹을 중복 로그인을 불가능 하게 만들었기 때문에 Google Cloud Service를 이용하여 직접 웹을 배포하였다.
	(http://35.243.127.223:8080/Databaase/main.html)

 - 2. 동시에 같은 제품을 구매할 수 있다.
    - 우리 제품을 동시에 구매할 때 중점을 맞춰야 하는 곳을 재고가 얼마 남지 않았을 때로 지정했다.
    - 총 5명의 사용자가 장바구니에 a라는 제품을 넣어두었다. 그러나 a의 재고가 1명만 구매 할 분량만 되었을때, 나머지 4명의 사용자는 구매에 실패하고 한 명 만 구매에 성공하게 한다.
    - 로직은 다음과 같다.
       Step1) conn.setAutoCommit(false)을 이용하여 먼저 자동 커밋을 종료한 후 만약을 위해 가장 처음에 commit을 시행했다.
       Step2) 유저의 장바구니 정보를 가져와 장바구니에 아이템이 있는지 확인 하였다.
	- 장바구니에 아이템이 있다: Step3으로
	- 장바구니에 아이템이 없다: 장바구니에 아이템이 없음을 나타내고 다음페이지로 이동하였다.
       Step3) 쇼핑백에 있는 아이템의 재고 수량을 확인 후 재고가 있는지 여부를 확인 하였다.
	- SELECT ~ LOCK IN SHARE MODE 구문을 이용하여 앞으로의 과정(step3~8)에 사용되는 모든 Table의 Row등을 LOCK시켰다.
	- 한 아이템이라고 재고가 없을 경우: 실패를 나타내고 다음 페이지로 이동하였다.
	- 모든 아이템의 재고가 존재할 경우:  Step4로
       Step4) 주문의 마지막 No를 계산한다.
       Step5) 장바구니에 포함된 아이템을 읽어온다.
       Step6) 각 아이템을 주문에 추가하고, 아이템의 재고수량을 감소한다.
       Step7) 해당 사용자의 장바구니 내역에 있는 모든 아이템을 삭제한다.
       Step8) 해당 사용자의 지역에 따른 배송업체를 확인 후 count를 1 증가시킨다.
       Step9) 이 모든 과정이 성공하였을 경우 commit한다.
	    Step3~8 까지 한번이라도 lock에 걸려 sql error가 발생하면 rollback하여 데이터는 Step1에서 처음 commit한 상태로 돌아간 후 유저는 다시 Step3으로 돌아가 다시 로직을 반복한다. (try-catch(SQLException)이용) 이를 통해 데이터의 무결성과 일관성을 유지할 수 있다.
      Step10) Connection을 close한다.
      Step11) 구매 성공을 나타내고 다음페이지로 이동한다.
    - 구매에 실패한 유저의 경우 장바구니에 여전히 아이템들이 남아있다.
    - 만약 동시에 구매 시 충분한 재고가 있다면 모은 유저의 구매는 성공하게 된다. (Step9에 의해 lock이 걸리더라도 다시 시도하여 구매에 성공하게 된다.)

 - 3. purchase.jsp에 기능이 구현되어 있다.